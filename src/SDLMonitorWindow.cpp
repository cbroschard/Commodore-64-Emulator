#include "SDLMonitorWindow.h"
#include <algorithm>
#include <cstring>

static const uint8_t font8x8_basic[96][8] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // space
    {0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00}, // !
    {0x66,0x66,0x22,0x00,0x00,0x00,0x00,0x00}, // "
    {0x36,0x36,0x7F,0x36,0x7F,0x36,0x36,0x00}, // #
    {0x0C,0x3E,0x03,0x1E,0x30,0x1F,0x0C,0x00}, // $
    {0x00,0x63,0x33,0x18,0x0C,0x66,0x63,0x00}, // %
    {0x1C,0x36,0x1C,0x3B,0x33,0x36,0x1C,0x00}, // &
    {0x06,0x06,0x03,0x00,0x00,0x00,0x00,0x00}, // '
    {0x18,0x0C,0x06,0x06,0x06,0x0C,0x18,0x00}, // (
    {0x18,0x30,0x60,0x60,0x60,0x30,0x18,0x00}, // )
    {0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00}, // *
    {0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00}, // +
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30}, // ,
    {0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00}, // -
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00}, // .
    {0x00,0x60,0x30,0x18,0x0C,0x06,0x00,0x00}, // /
    {0x3C,0x66,0x6E,0x76,0x66,0x66,0x3C,0x00}, // 0
    {0x18,0x18,0x38,0x18,0x18,0x18,0x3C,0x00}, // 1
    {0x3C,0x66,0x06,0x0C,0x30,0x60,0x7E,0x00}, // 2
    {0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00}, // 3
    {0x06,0x0E,0x1E,0x66,0x7F,0x06,0x06,0x00}, // 4
    {0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00}, // 5
    {0x3C,0x66,0x60,0x7C,0x66,0x66,0x3C,0x00}, // 6
    {0x7E,0x66,0x06,0x0C,0x18,0x18,0x18,0x00}, // 7
    {0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00}, // 8
    {0x3C,0x66,0x66,0x3E,0x06,0x66,0x3C,0x00}, // 9
    {0x00,0x00,0x18,0x00,0x00,0x18,0x00,0x00}, // :
    {0x00,0x00,0x18,0x00,0x00,0x18,0x18,0x30}, // ;
    {0x06,0x0C,0x18,0x30,0x18,0x0C,0x06,0x00}, // <
    {0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00}, // =
    {0x60,0x30,0x18,0x0C,0x18,0x30,0x60,0x00}, // >
    {0x3C,0x66,0x06,0x0C,0x18,0x00,0x18,0x00}, // ?
    {0x3C,0x66,0x6E,0x6E,0x60,0x62,0x3C,0x00}, // @
    {0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00}, // A
    {0x7C,0x66,0x66,0x7C,0x66,0x66,0x7C,0x00}, // B
    {0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00}, // C
    {0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00}, // D
    {0x7E,0x60,0x60,0x78,0x60,0x60,0x7E,0x00}, // E
    {0x7E,0x60,0x60,0x78,0x60,0x60,0x60,0x00}, // F
    {0x3C,0x66,0x60,0x6E,0x66,0x66,0x3C,0x00}, // G
    {0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00}, // H
    {0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // I
    {0x1E,0x0C,0x0C,0x0C,0x0C,0xCC,0x78,0x00}, // J
    {0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00}, // K
    {0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00}, // L
    {0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x00}, // M
    {0x66,0x76,0x7F,0x7F,0x6E,0x66,0x66,0x00}, // N
    {0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00}, // O
    {0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00}, // P
    {0x3C,0x66,0x66,0x66,0x6A,0x6C,0x36,0x00}, // Q
    {0x7C,0x66,0x66,0x7C,0x78,0x6C,0x66,0x00}, // R
    {0x3C,0x66,0x60,0x3C,0x06,0x66,0x3C,0x00}, // S
    {0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00}, // T
    {0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00}, // U
    {0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00}, // V
    {0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00}, // W
    {0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00}, // X
    {0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00}, // Y
    {0x7E,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00}, // Z
    {0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00}, // [
    {0x00,0x06,0x0C,0x18,0x30,0x60,0x00,0x00}, // Backslash
    {0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00}, // ]
    {0x18,0x3C,0x7E,0x18,0x18,0x18,0x18,0x00}, // ^
    {0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00}, // _
    {0x18,0x0C,0x00,0x00,0x00,0x00,0x00,0x00}, // `
    {0x00,0x00,0x3C,0x06,0x3E,0x66,0x3E,0x00}, // a
    {0x60,0x60,0x7C,0x66,0x66,0x66,0x7C,0x00}, // b
    {0x00,0x00,0x3C,0x60,0x60,0x60,0x3C,0x00}, // c
    {0x06,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00}, // d
    {0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00}, // e
    {0x1C,0x30,0x7C,0x30,0x30,0x30,0x30,0x00}, // f
    {0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x3C}, // g
    {0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x00}, // h
    {0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00}, // i
    {0x06,0x00,0x06,0x06,0x06,0x06,0x06,0x3C}, // j
    {0x60,0x60,0x66,0x6C,0x78,0x6C,0x66,0x00}, // k
    {0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // l
    {0x00,0x00,0x66,0x7F,0x7F,0x6B,0x63,0x00}, // m
    {0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00}, // n
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00}, // o
    {0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60}, // p
    {0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x06}, // q
    {0x00,0x00,0x5C,0x66,0x60,0x60,0x60,0x00}, // r
    {0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00}, // s
    {0x30,0x30,0x78,0x30,0x30,0x30,0x1C,0x00}, // t
    {0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00}, // u
    {0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00}, // v
    {0x00,0x00,0x63,0x6B,0x7F,0x3E,0x36,0x00}, // w
    {0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00}, // x
    {0x00,0x00,0x66,0x66,0x66,0x3E,0x0C,0x78}, // y
    {0x00,0x00,0x7E,0x0C,0x18,0x30,0x7E,0x00}, // z
    {0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00}, // {
    {0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00}, // |
    {0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00}, // }
    {0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00}, // ~
    {0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x00}  // DEL (block)
};

SDLMonitorWindow::SDLMonitorWindow() :
    width(900),
    height(550),
    charWidth(8),
    charHeight(8),
    opened(false),
    scrollOffset(0)
{

}

SDLMonitorWindow::~SDLMonitorWindow()
{
    close();
}

void SDLMonitorWindow::createFontTexture()
{
    if (!ren) return;

    // Create a surface first to manipulate pixels easily
    SDL_Surface* surf = SDL_CreateRGBSurfaceWithFormat(0, 96 * 8, 8, 32, SDL_PIXELFORMAT_RGBA32);
    if (!surf) return;

    SDL_LockSurface(surf);
    uint32_t* pixels = (uint32_t*)surf->pixels;

    for (int c = 0; c < 96; ++c)
    {
        for (int y = 0; y < 8; ++y)
        {
            uint8_t row = font8x8_basic[c][y];
            for (int x = 0; x < 8; ++x)
            {
                // Check bit (most significant bit is left)
                bool pixelOn = (row >> (7 - x)) & 1;

                int surfX = c * 8 + x;
                int surfY = y;

                // White text, transparent background
                pixels[surfY * (surf->pitch / 4) + surfX] = pixelOn ? 0xFFFFFFFF : 0x00000000;
            }
        }
    }
    SDL_UnlockSurface(surf);

    // Convert to texture
    fontTex = SDL_CreateTextureFromSurface(ren, surf);
    SDL_FreeSurface(surf);

    // Enable blending so transparency works
    SDL_SetTextureBlendMode(fontTex, SDL_BLENDMODE_BLEND);
}

bool SDLMonitorWindow::open(const char* title, int w, int h, ExecFn exec)
{
    if (opened) return true;

    width = w; height = h;
    execFn = std::move(exec);

    win = SDL_CreateWindow(title,
                           SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
                           width, height,
                           SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);
    if (!win) return false;

    ren = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    if (!ren)
    {
        SDL_DestroyWindow(win);
        win = nullptr;
        return false;
    }

    createFontTexture();

    opened = true;
    lines.clear();
    input.clear();
    scrollOffset = 0;

    // Enables SDL_TEXTINPUT events for typing
    SDL_StartTextInput();

    lines.push_back("ML Monitor (SDL) - type 'help' and press Enter");
    lines.push_back("------------------------------------------------");

    return true;
}

void SDLMonitorWindow::close()
{
    if (!opened) return;

    SDL_StopTextInput();

    if (fontTex) SDL_DestroyTexture(fontTex);
    fontTex = nullptr;

    if (ren) SDL_DestroyRenderer(ren);
    if (win) SDL_DestroyWindow(win);
    ren = nullptr;
    win = nullptr;
    opened = false;
}

void SDLMonitorWindow::appendLine(const std::string& s)
{
    lines.push_back(s);
    // clamp scroll to bottom (reset offset)
    scrollOffset = 0;
}

void SDLMonitorWindow::addChar(char c)
{
    // Filter non-printable
    if (c >= 32 && c <= 126)
        input.push_back(c);
}

void SDLMonitorWindow::backspace()
{
    if (!input.empty())
        input.pop_back();
}

void SDLMonitorWindow::submitCommand()
{
    // Echo command
    lines.push_back("> " + input);

    std::string out;
    if (execFn && !input.empty())
        out = execFn(input);

    // Split output into lines
    size_t start = 0;
    while (!out.empty() && start < out.size())
    {
        size_t nl = out.find('\n', start);
        if (nl == std::string::npos)
        {
            lines.push_back(out.substr(start));
            break;
        }
        lines.push_back(out.substr(start, nl - start));
        start = nl + 1;
    }

    input.clear();
    scrollOffset = 0;
}

void SDLMonitorWindow::handleEvent(const SDL_Event& e)
{
    if (!opened) return;

    // Handle window close logic
    if (e.type == SDL_WINDOWEVENT)
    {
        if (e.window.windowID == SDL_GetWindowID(win))
        {
            if (e.window.event == SDL_WINDOWEVENT_CLOSE)
                close();
            else if (e.window.event == SDL_WINDOWEVENT_RESIZED)
            {
                width = e.window.data1;
                height = e.window.data2;
            }
        }
        return;
    }

    // Filter events for this window
    const Uint32 myId = SDL_GetWindowID(win);
    if ((e.type == SDL_KEYDOWN || e.type == SDL_KEYUP) && e.key.windowID != myId) return;
    if (e.type == SDL_TEXTINPUT && e.text.windowID != myId) return;
    if (e.type == SDL_MOUSEWHEEL && e.wheel.windowID != myId) return;

    if (e.type == SDL_TEXTINPUT)
    {
        for (const char* p = e.text.text; *p; ++p)
            addChar(*p);
    }
    else if (e.type == SDL_KEYDOWN)
    {
        switch (e.key.keysym.sym)
        {
            case SDLK_BACKSPACE: backspace(); break;
            case SDLK_RETURN:
            case SDLK_KP_ENTER:  submitCommand(); break;
            case SDLK_ESCAPE:    close(); break;
            case SDLK_PAGEUP:    scrollOffset += 10; break;
            case SDLK_PAGEDOWN:  scrollOffset = std::max(scrollOffset - 10, 0); break;
            default: break;
        }

        // Clamp scroll
        if (scrollOffset > (int)lines.size()) scrollOffset = (int)lines.size();
    }
    else if (e.type == SDL_MOUSEWHEEL)
    {
        if (e.wheel.y > 0) scrollOffset++;
        if (e.wheel.y < 0) scrollOffset = std::max(scrollOffset - 1, 0);

        if (scrollOffset > (int)lines.size()) scrollOffset = (int)lines.size();
    }
}

void SDLMonitorWindow::drawString(int x, int y, const std::string& str, const SDL_Color& color)
{
    if (!fontTex) return;

    SDL_SetTextureColorMod(fontTex, color.r, color.g, color.b);

    SDL_Rect src{0, 0, 8, 8}; // 8x8 char
    SDL_Rect dst{x, y, 8, 8};

    for (char c : str)
    {
        // Calculate index in our flat font strip (ASCII 32 to 127)
        int index = (unsigned char)c - 32;
        if (index < 0 || index >= 96) index = 95; // default to block for unknown

        src.x = index * 8;

        SDL_RenderCopy(ren, fontTex, &src, &dst);
        dst.x += 8;
    }
}

void SDLMonitorWindow::render()
{
    if (!opened || !ren) return;

    // Background Color (Deep Dark Grey/Black)
    SDL_SetRenderDrawColor(ren, 20, 20, 20, 255);
    SDL_RenderClear(ren);

    // Padding settings
    const int padding = 5;
    const int lineHeight = 10; // 8px char + 2px spacing

    // Color: Classic C64 Light Blue/Cyan for text
    SDL_Color textColor = {160, 160, 255, 255};
    SDL_Color promptColor = {100, 255, 100, 255}; // Green prompt

    // 1. Render Input Line at bottom
    int inputY = height - padding - lineHeight;

    std::string prompt = "> ";
    drawString(padding, inputY, prompt, promptColor);
    drawString(padding + (prompt.length() * 8), inputY, input, textColor);

    if ((SDL_GetTicks() / 500) % 2 == 0)
    {
        int cursorX = padding + (prompt.length() + input.length()) * 8;
        SDL_Rect cursorRect = { cursorX, inputY, 8, 8 };
        SDL_SetRenderDrawColor(ren, 200, 200, 200, 255);
        SDL_RenderFillRect(ren, &cursorRect);
    }

    int historyBottomY = inputY - lineHeight;
    int historyCount = lines.size();

    // We iterate backwards from the end of the list minus scrollOffset
    int startIdx = historyCount - 1 - scrollOffset;

    int currentY = historyBottomY;

    for (int i = startIdx; i >= 0; --i)
    {
        if (currentY < 0) break; // Off top of screen

        drawString(padding, currentY, lines[i], textColor);
        currentY -= lineHeight;
    }

    // Scrollbar indicator (simple)
    if (scrollOffset > 0)
    {
        SDL_Rect scrollRect = { width - 5, 0, 5, 5 };
        SDL_SetRenderDrawColor(ren, 255, 0, 0, 255);
        SDL_RenderFillRect(ren, &scrollRect);
    }

    SDL_RenderPresent(ren);
}
